# 🔄 БІЗНЕС-ПРОЦЕСИ СИСТЕМИ ROOMY CRM
## Середній рівень деталізації - Взаємодія сутностей та автоматизація

---

## 📋 **ЗАГАЛЬНА ІНФОРМАЦІЯ**

### 🎯 **МЕТА ДОКУМЕНТУ**
Детальний опис ключових бізнес-процесів системи Roomy CRM, що демонструють взаємодію між сутностями, автоматизацію процесів, тригери та вплив змін статусів на інші компоненти системи.

### 🔗 **ЗВ'ЯЗКИ МІЖ ПРОЦЕСАМИ**
Кожен процес не існує ізольовано - зміни в одному процесі автоматично впливають на інші, створюючи комплексну екосистему управління.

---

## 🔄 **1. ПОВНИЙ ЖИТТЄВИЙ ЦИКЛ УСПІШНОГО БРОНЮВАННЯ**

### 📅 **Етап 1: Пошук та вибір об'єкта гостем**

**Процес:**
1. **Гість** здійснює пошук об'єкта через зовнішній інтерфейс
2. Система перевіряє **Property.isPublished = true** та **Property.isActive = true**
3. Система перевіряє доступність в **Scheduler** на вибрані дати
4. Система розраховує ціну з урахуванням сезонності та промо-акцій

**Тригери:**
- Перевірка конфліктів з існуючими резерваціями
- Автоматичний розрахунок цін
- Перевірка мінімального терміну бронювання

**Створювані сутності:**
- Тимчасова **Reservation** зі статусом `PENDING`
- **Transaction** з типом `RESERVATION_FEE` (якщо передоплата)

### 📅 **Етап 2: Підтвердження бронювання**

**Процес:**
1. **Reservation.status** змінюється з `PENDING` на `CONFIRMED`
2. **PaymentStatus** автоматично змінюється на `PAID` (якщо передоплата отримана)
3. **GuestStatus** встановлюється в `BOOKED`

**Критичні тригери:**
```typescript
// Псевдокод автоматизації
if (reservation.status === 'CONFIRMED') {
  // 1. Створення завдання прибирання
  createCleaningTask({
    propertyId: reservation.propertyId,
    scheduledDate: reservation.checkIn - 1 day,
    type: 'Pre-Arrival',
    status: 'Scheduled',
    priority: 'High'
  })
  
  // 2. Створення завдання підготовки
  createMaintenanceTask({
    propertyId: reservation.propertyId,
    scheduledDate: reservation.checkIn - 2 hours,
    type: 'INSPECTION',
    status: 'Scheduled',
    priority: 'High'
  })
  
  // 3. Блокування дат в Scheduler
  blockPropertyDates({
    propertyId: reservation.propertyId,
    startDate: reservation.checkIn,
    endDate: reservation.checkOut,
    reason: 'RESERVATION'
  })
  
  // 4. Відправка email підтвердження
  sendEmail({
    to: reservation.guest.email,
    template: 'CONFIRMATION',
    data: reservation
  })
}
```

**Створювані сутності:**
- **Cleaning** task (Pre-Arrival)
- **Maintenance** task (Inspection)
- **Scheduler** event (блокуючий)
- **Message** (email підтвердження)
- **Notification** (для менеджера)

### 📅 **Етап 3: Підготовка об'єкта**

**Процес:**
1. **Cleaning** task виконується за 1 день до заселення
2. **Maintenance** task виконується за 2 години до заселення
3. Після завершення обох завдань **Property** стає готовим до заселення

**Тригери:**
```typescript
// Коли Cleaning task завершується
if (cleaningTask.status === 'COMPLETED') {
  // Оновлення статусу готовності
  updateProperty({
    id: cleaningTask.propertyId,
    isReadyForCheckIn: true
  })
  
  // Сповіщення гостя
  sendMessage({
    to: reservation.guest,
    type: 'SMS',
    content: 'Your property is ready for check-in!'
  })
}

// Коли Maintenance task завершується
if (maintenanceTask.status === 'COMPLETED') {
  // Фінальна перевірка готовності
  if (allTasksCompleted(reservation.propertyId)) {
    markPropertyReady(reservation.propertyId)
  }
}
```

### 📅 **Етап 4: Заселення гостя**

**Процес:**
1. Гість прибуває на об'єкт
2. **Reservation.guestStatus** змінюється на `CHECKED_IN`
3. **Reservation.checkInTime** фіксується
4. Створюється **Cleaning** task на Post-Checkout

**Тригери:**
```typescript
if (reservation.guestStatus === 'CHECKED_IN') {
  // Створення завдання прибирання після виселення
  createCleaningTask({
    propertyId: reservation.propertyId,
    scheduledDate: reservation.checkOut + 2 hours,
    type: 'Post-Checkout',
    status: 'Scheduled',
    priority: 'High'
  })
  
  // Сповіщення про заселення
  notifyManager({
    message: `Guest ${reservation.guest.name} checked in at ${reservation.property.name}`
  })
}
```

### 📅 **Етап 5: Проживання та обслуговування**

**Процес:**
1. Моніторинг стану об'єкта
2. Обробка запитів гостя
3. Планування додаткових послуг

**Можливі тригери:**
- Створення **Maintenance** завдань за запитом
- Створення **Cleaning** завдань (Mid-Stay)
- Оновлення **Reservation** нотаток

### 📅 **Етап 6: Виселення та фінансові розрахунки**

**Процес:**
1. **Reservation.guestStatus** змінюється на `CHECKED_OUT`
2. **Reservation.checkOutTime** фіксується
3. Запускається **Cleaning** task (Post-Checkout)
4. Розраховується фінальна сума до виплати власнику

**Фінансові тригери:**
```typescript
if (reservation.guestStatus === 'CHECKED_OUT') {
  // Розрахунок виплати власнику
  const ownerPayout = calculateOwnerPayout({
    totalAmount: reservation.totalAmount,
    commission: reservation.commission,
    cleaningCost: cleaningTask.cost,
    maintenanceCost: maintenanceTask.cost
  })
  
  // Створення транзакції виплати
  createTransaction({
    type: 'OWNER_PAYOUT',
    amount: ownerPayout,
    userId: reservation.property.ownerId,
    reservationId: reservation.id,
    status: 'PENDING'
  })
  
  // Планування виплати
  scheduleOwnerPayout({
    ownerId: reservation.property.ownerId,
    amount: ownerPayout,
    scheduledDate: getNextPayoutDate(reservation.property.owner.payoutSchedule)
  })
}
```

**Створювані сутності:**
- **Transaction** (OWNER_PAYOUT)
- **Cleaning** task (Post-Checkout)
- **Notification** (для власника)

---

## ❌ **2. ПРОЦЕС СКАСУВАННЯ БРОНЮВАННЯ**

### 🚫 **Етап 1: Ініціація скасування**

**Процес:**
1. Гість або менеджер ініціює скасування
2. **Reservation.status** змінюється на `CANCELLED`
3. **Reservation.cancellationReason** фіксується
4. **Reservation.cancellationDate** встановлюється

**Критичні тригери:**
```typescript
if (reservation.status === 'CANCELLED') {
  // 1. Скасування пов'язаних завдань
  cancelRelatedTasks({
    reservationId: reservation.id,
    types: ['CLEANING', 'MAINTENANCE']
  })
  
  // 2. Розблокування дат в Scheduler
  unblockPropertyDates({
    propertyId: reservation.propertyId,
    startDate: reservation.checkIn,
    endDate: reservation.checkOut
  })
  
  // 3. Розрахунок штрафу за скасування
  const cancellationFee = calculateCancellationFee({
    totalAmount: reservation.totalAmount,
    cancellationDate: new Date(),
    checkInDate: reservation.checkIn,
    cancellationPolicy: reservation.property.cancellationPolicy
  })
  
  // 4. Створення транзакції повернення
  createTransaction({
    type: 'REFUND',
    amount: reservation.totalAmount - cancellationFee,
    userId: reservation.guestId,
    reservationId: reservation.id,
    status: 'PENDING'
  })
  
  // 5. Сповіщення всіх зацікавлених сторін
  notifyStakeholders({
    guest: reservation.guest,
    owner: reservation.property.owner,
    manager: reservation.assignedManager
  })
}
```

### 🔄 **Етап 2: Обробка пов'язаних сутностей**

**Процеси скасування:**

**Cleaning Tasks:**
```typescript
// Всі пов'язані завдання прибирання скасовуються
const cleaningTasks = getCleaningTasksByReservation(reservation.id)
cleaningTasks.forEach(task => {
  if (task.status === 'SCHEDULED' || task.status === 'PENDING') {
    updateCleaningTask(task.id, { status: 'CANCELLED' })
  }
})
```

**Maintenance Tasks:**
```typescript
// Всі пов'язані завдання обслуговування скасовуються
const maintenanceTasks = getMaintenanceTasksByReservation(reservation.id)
maintenanceTasks.forEach(task => {
  if (task.status === 'SCHEDULED' || task.status === 'PENDING') {
    updateMaintenanceTask(task.id, { status: 'CANCELLED' })
  }
})
```

**Scheduler Events:**
```typescript
// Блокувальні події видаляються
const schedulerEvents = getSchedulerEventsByReservation(reservation.id)
schedulerEvents.forEach(event => {
  if (event.eventType === 'RESERVATION_BLOCK') {
    deleteSchedulerEvent(event.id)
  }
})
```

### 💰 **Етап 3: Фінансові розрахунки**

**Розрахунок повернення:**
```typescript
const calculateRefund = (reservation) => {
  const cancellationPolicy = reservation.property.cancellationPolicy
  const daysUntilCheckIn = getDaysDifference(new Date(), reservation.checkIn)
  
  let refundPercentage = 0
  
  switch (cancellationPolicy) {
    case 'FLEXIBLE':
      if (daysUntilCheckIn >= 1) refundPercentage = 100
      else if (daysUntilCheckIn >= 0) refundPercentage = 50
      break
      
    case 'MODERATE':
      if (daysUntilCheckIn >= 5) refundPercentage = 100
      else if (daysUntilCheckIn >= 1) refundPercentage = 50
      break
      
    case 'STRICT':
      if (daysUntilCheckIn >= 7) refundPercentage = 50
      break
  }
  
  return {
    refundAmount: reservation.totalAmount * (refundPercentage / 100),
    cancellationFee: reservation.totalAmount * ((100 - refundPercentage) / 100),
    refundPercentage
  }
}
```

**Створення транзакцій:**
```typescript
// Транзакція повернення гостю
createTransaction({
  type: 'REFUND',
  amount: refundAmount,
  userId: reservation.guestId,
  reservationId: reservation.id,
  status: 'PENDING',
  description: `Refund for cancelled reservation ${reservation.id}`
})

// Транзакція штрафу (якщо є)
if (cancellationFee > 0) {
  createTransaction({
    type: 'CANCELLATION_FEE',
    amount: cancellationFee,
    userId: reservation.guestId,
    reservationId: reservation.id,
    status: 'COMPLETED',
    description: `Cancellation fee for reservation ${reservation.id}`
  })
}
```

---

## 🔧 **3. УПРАВЛІННЯ ТЕХНІЧНИМ ОБСЛУГОВУВАННЯМ**

### 🛠️ **Етап 1: Створення заявки на обслуговування**

**Процес:**
1. Менеджер, гість або система створює **Maintenance** заявку
2. **Maintenance.type** визначається (REPAIR, INSPECTION, EMERGENCY, тощо)
3. **Maintenance.priority** встановлюється автоматично або вручну
4. **Maintenance.status** встановлюється в `PENDING`

**Автоматичне призначення пріоритету:**
```typescript
const assignPriority = (maintenanceType, description) => {
  // Аварійні ситуації - найвищий пріоритет
  if (maintenanceType === 'EMERGENCY') return 'URGENT'
  
  // Критичні системи - високий пріоритет
  const criticalKeywords = ['water', 'electricity', 'heating', 'security']
  if (criticalKeywords.some(keyword => description.toLowerCase().includes(keyword))) {
    return 'HIGH'
  }
  
  // Звичайне обслуговування
  return 'NORMAL'
}
```

### 👷 **Етап 2: Призначення виконавця**

**Процес призначення:**
```typescript
const assignMaintenanceStaff = (maintenanceTask) => {
  // 1. Визначення типу необхідних робіт
  const requiredSkills = getRequiredSkills(maintenanceTask.type)
  
  // 2. Пошук доступних спеціалістів
  const availableStaff = getAvailableMaintenanceStaff({
    skills: requiredSkills,
    date: maintenanceTask.scheduledDate,
    location: maintenanceTask.property.location
  })
  
  // 3. Автоматичне призначення або запропонувати менеджеру
  if (availableStaff.length === 1) {
    // Автоматичне призначення
    return assignTask(maintenanceTask.id, availableStaff[0].id)
  } else if (availableStaff.length > 1) {
    // Запропонувати менеджеру вибір
    notifyManager({
      type: 'STAFF_ASSIGNMENT_NEEDED',
      taskId: maintenanceTask.id,
      availableStaff: availableStaff,
      message: `Multiple staff available for ${maintenanceTask.type} task`
    })
  } else {
    // Немає доступних спеціалістів
    notifyManager({
      type: 'NO_STAFF_AVAILABLE',
      taskId: maintenanceTask.id,
      message: `No available staff for ${maintenanceTask.type} task`
    })
  }
}
```

**Критерії призначення:**
- Спеціалізація (сантехнік, електрик, тощо)
- Доступність на заплановану дату
- Географічна близькість до об'єкта
- Поточне навантаження
- Рейтинг якості роботи

### 📅 **Етап 3: Планування та вплив на доступність**

**Процес планування:**
```typescript
const scheduleMaintenanceTask = (maintenanceTask) => {
  // 1. Перевірка конфліктів з існуючими бронюваннями
  const conflictingReservations = getConflictingReservations({
    propertyId: maintenanceTask.propertyId,
    startDate: maintenanceTask.scheduledDate,
    endDate: maintenanceTask.estimatedCompletionDate
  })
  
  if (conflictingReservations.length > 0) {
    // Запропонувати альтернативні дати
    const alternativeDates = findAlternativeDates(maintenanceTask)
    notifyManager({
      type: 'SCHEDULE_CONFLICT',
      taskId: maintenanceTask.id,
      conflicts: conflictingReservations,
      alternatives: alternativeDates
    })
  }
  
  // 2. Блокування об'єкта (якщо потрібно)
  if (maintenanceTask.blocksProperty) {
    createSchedulerEvent({
      propertyId: maintenanceTask.propertyId,
      eventType: 'MAINTENANCE_BLOCK',
      startDate: maintenanceTask.scheduledDate,
      endDate: maintenanceTask.estimatedCompletionDate,
      title: `Maintenance: ${maintenanceTask.title}`,
      status: 'ACTIVE'
    })
  }
  
  // 3. Сповіщення гостей (якщо є активні бронювання)
  if (maintenanceTask.affectsGuests) {
    notifyAffectedGuests(maintenanceTask)
  }
}
```

### ✅ **Етап 4: Виконання та контроль якості**

**Процес виконання:**
```typescript
const executeMaintenanceTask = (maintenanceTask) => {
  // 1. Оновлення статусу на "In Progress"
  updateMaintenanceTask(maintenanceTask.id, { status: 'IN_PROGRESS' })
  
  // 2. Сповіщення про початок робіт
  notifyStakeholders({
    type: 'MAINTENANCE_STARTED',
    task: maintenanceTask,
    message: `Maintenance work started: ${maintenanceTask.title}`
  })
  
  // 3. Моніторинг прогресу
  startProgressMonitoring(maintenanceTask.id)
}

const completeMaintenanceTask = (maintenanceTask, completionData) => {
  // 1. Оновлення статусу
  updateMaintenanceTask(maintenanceTask.id, {
    status: 'COMPLETED',
    completedDate: new Date(),
    actualCost: completionData.cost,
    notes: completionData.notes,
    photos: completionData.photos
  })
  
  // 2. Розблокування об'єкта
  if (maintenanceTask.blocksProperty) {
    removeSchedulerBlock(maintenanceTask.propertyId, maintenanceTask.id)
  }
  
  // 3. Оновлення рейтингу виконавця
  updateStaffRating(maintenanceTask.assignedUserId, completionData.quality)
  
  // 4. Створення наступного планового обслуговування
  if (maintenanceTask.type === 'PREVENTIVE') {
    scheduleNextMaintenance(maintenanceTask)
  }
}
```

---

## 🔄 **4. ВЗАЄМОЗВ'ЯЗКИ СТАТУСІВ ТА ТРИГЕРИ**

### 📊 **Матриця впливу статусів**

| Зміна статусу | Впливає на | Дія |
|---------------|------------|-----|
| `Reservation.status` → `CONFIRMED` | `Cleaning.status` | Створення Pre-Arrival завдання |
| `Reservation.status` → `CONFIRMED` | `Scheduler` | Блокування дат |
| `Reservation.status` → `CONFIRMED` | `Message` | Відправка підтвердження |
| `Reservation.paymentStatus` → `PAID` | `Reservation.status` | Автоматичне підтвердження |
| `Reservation.guestStatus` → `CHECKED_IN` | `Cleaning.status` | Створення Post-Checkout завдання |
| `Reservation.guestStatus` → `CHECKED_OUT` | `Transaction` | Створення виплати власнику |
| `Cleaning.status` → `COMPLETED` | `Property.isReadyForCheckIn` | Оновлення готовності |
| `Maintenance.status` → `IN_PROGRESS` | `Scheduler` | Блокування об'єкта |
| `Maintenance.status` → `COMPLETED` | `Scheduler` | Розблокування об'єкта |

### ⚡ **Критичні тригери системи**

**1. Автоматичне підтвердження бронювань:**
```typescript
// Коли оплата отримана
if (reservation.paymentStatus === 'PAID' && reservation.status === 'PENDING') {
  reservation.status = 'CONFIRMED'
  triggerReservationConfirmation(reservation)
}
```

**2. Автоматичне створення завдань:**
```typescript
// При підтвердженні бронювання
const triggerReservationConfirmation = (reservation) => {
  createCleaningTask({
    propertyId: reservation.propertyId,
    scheduledDate: reservation.checkIn - 1 day,
    type: 'Pre-Arrival',
    priority: 'HIGH'
  })
  
  createMaintenanceTask({
    propertyId: reservation.propertyId,
    scheduledDate: reservation.checkIn - 2 hours,
    type: 'INSPECTION',
    priority: 'HIGH'
  })
}
```

**3. Автоматичне сповіщення:**
```typescript
// При зміні статусу гостя
if (reservation.guestStatus === 'NO_SHOW') {
  notifyManager({
    type: 'GUEST_NO_SHOW',
    reservation: reservation,
    message: `Guest ${reservation.guest.name} did not show up for check-in`
  })
  
  // Автоматичне скасування завдань прибирання
  cancelCleaningTasks(reservation.id)
}
```

---

## 🎯 **ВИСНОВКИ ТА РЕКОМЕНДАЦІЇ**

### ✅ **ПЕРЕВАГИ ПОТОЧНОЇ СИСТЕМИ**
- **Повна автоматизація** ключових процесів
- **Інтегровані тригери** між модулями
- **Автоматичне призначення** завдань
- **Фінансова прозорість** на всіх етапах

### ⚠️ **ПОТЕНЦІЙНІ ПОЛІПШЕННЯ**
- **Розширення автоматизації** для складніших сценаріїв
- **Покращення алгоритмів** призначення персоналу
- **Додавання машинного навчання** для прогнозування потреб
- **Інтеграція з IoT** для автоматичного моніторингу

### 🚀 **НАПРЯМКИ РОЗВИТКУ**
- **Предиктивне обслуговування** на основі даних
- **Автоматичне ціноутворення** залежно від попиту
- **Розумні рекомендації** для оптимізації процесів
- **Мобільний додаток** для персоналу на об'єктах

**Система демонструє високий рівень автоматизації та інтеграції, що забезпечує ефективне управління всіма аспектами бізнесу нерухомості.** 🏠✨
